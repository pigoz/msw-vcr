{"version":3,"sources":["../src/index.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;AAAA,OAAO,QAAQ;AACf,OAAO,UAAU;AACjB,SAAS,eAAe,0BAA0B;AAClD,SAAyB,YAAY;AAOrC,SAAS,aAAa,cAA2C;AAC/D,QAAM,UAAU;AAAA,IACd,KAAK,KAAK;AAAA,IACV,MAAM,KAAK;AAAA,IACX,KAAK,KAAK;AAAA,IACV,QAAQ,KAAK;AAAA,IACb,SAAS,KAAK;AAAA,IACd,MAAM,KAAK;AAAA,IACX,OAAO,KAAK;AAAA,EACd;AAEA,SAAO,aAAa,IAAI,CAAC,YAAiB;AACxC,UAAM,SAAS,QAAQ,QAAQ;AAC/B,UAAM,UAAU,QAAQ,MAAM;AAE9B,WAAO;AAAA,MAAQ,QAAQ,QAAQ;AAAA,MAAK,CAAC,MAAM,KAAK,QAC9C,IAAI,IAAI,OAAO,QAAQ,SAAS,MAAM,GAAG,IAAI,KAAK,QAAQ,SAAS,IAAI,CAAC;AAAA,IAC1E;AAAA,EACF,CAAC;AACH;AAEO,SAAS,YAAY,WAAmB,UAA4B;AACzE,WAAS,OAAO,MAAc;AAhChC;AAiCI,UAAM,eAAe,KAAK,QAAQ,OAAO,aAAa,GAAG,IAAI,OAAO;AACpE,UAAM,WAAW,oBAAI,IAAI;AACzB,UAAM,eAAe,oBAAI,IAAI;AAE7B,UAAM,eAAe,GAAG,eAAe,YAAY,KAC7C,QAAG,aAAa,YAAY,MAA5B,YAAiC,CAAC,IACpC,CAAC;AAEL,UAAM,SAAS;AAAA,MACb,GAAG,aAAa,YAAY;AAAA,MAC5B,GAAG;AAAA,IACL;AAEA,WAAO,OAAO,GAAG,iBAAiB,CAAC,YAAY;AAE7C,eAAS,IAAI,QAAQ,IAAI,OAAO;AAAA,IAClC,CAAC;AAcD,WAAO,OAAO,GAAG,mBAAmB,CAAC,WAAW,cAAc;AAC5D,YAAM,WAAW,SAAS,IAAI,SAAS;AAEvC,YAAM,UAAU,KAAK,MAAM,KAAK,UAAU,QAAQ,CAAC;AACnD,cAAQ,UAAU,SAAS,QAAQ,IAAI;AAEvC,YAAM,WAAW,KAAK,MAAM,KAAK,UAAU,SAAS,CAAC;AACrD,eAAS,UAAU,UAAU,QAAQ,IAAI;AAEzC,mBAAa,IAAI,EAAE,SAAS,SAAS,CAAC;AAAA,IACxC,CAAC;AAED,aAAS,QAAQ;AACf,YAAM,OAAO;AAEb,mBAAa,QAAQ,CAAC,gBAAgB;AACpC,aAAK,KAAK,WAAW;AAAA,MACvB,CAAC;AAED,SAAG,eAAe,cAAc,KAAK,UAAU,MAAM,MAAM,CAAC,CAAC;AAAA,IAC/D;AAEA,UAAM,qBAAqB,EAAE,OAAO,SAAS,QAAQ,SAAS;AAE9D,WAAO,OAAO;AAAA,MACZ,oBAAoB,mBAAmB,OAAO,kBAAkB;AAAA,IAClE,CAAC;AAED,WAAO,SAAS,QAAQ;AACtB,aAAO,MAAM;AACb,YAAM;AAAA,IACR;AAAA,EACF;AAEA,WAAe,SACb,MACA,UACY;AAAA;AACZ,YAAM,QAAQ,OAAO,IAAI;AACzB,aAAO,SAAS,EAAE,QAAQ,MAAM,MAAM,CAAC;AAAA,IACzC;AAAA;AAEA,SAAO;AAAA,IACL;AAAA,IACA;AAAA,EACF;AACF","sourcesContent":["import fs from \"fs-extra\";\nimport path from \"path\";\nimport { setupServer as mswSetupServerNode } from \"msw/node\";\nimport { RequestHandler, rest } from \"msw\";\n\ntype Config = {\n  cassetteDir: string;\n  onUnhandledRequest: \"error\" | \"record\";\n};\n\nfunction makeHandlers(existingJson: unknown[]): RequestHandler[] {\n  const methods = {\n    GET: rest.get,\n    POST: rest.post,\n    PUT: rest.put,\n    DELETE: rest.delete,\n    OPTIONS: rest.options,\n    HEAD: rest.head,\n    PATCH: rest.patch,\n  };\n\n  return existingJson.map((handler: any) => {\n    const method = handler.request.method as keyof typeof methods;\n    const builder = methods[method];\n\n    return builder(handler.request.url, (_req, res, ctx) =>\n      res(ctx.status(handler.response.status), ctx.body(handler.response.body))\n    );\n  });\n}\n\nexport function setupServer(config: Config, ...handlers: RequestHandler[]) {\n  function listen(name: string) {\n    const cassetteFile = path.resolve(config.cassetteDir, `${name}.json`);\n    const requests = new Map();\n    const transactions = new Set();\n\n    const existingJson = fs.pathExistsSync(cassetteFile)\n      ? ((fs.readJsonSync(cassetteFile) ?? []) as unknown[])\n      : [];\n\n    const server = mswSetupServerNode(\n      ...makeHandlers(existingJson),\n      ...handlers\n    );\n\n    server.events.on(\"request:start\", (request) => {\n      // Record every dispatched request.\n      requests.set(request.id, request);\n    });\n\n    // server.events.on(\"request:match\", (request) => {\n    //   console.log(\"%s %s has a handler\", request.method, request.url.href);\n    // });\n\n    // server.events.on(\"request:unhandled\", (request) => {\n    //   console.log(\"%s %s has no handler\", request.method, request.url.href);\n    // });\n\n    // Since we're not providing any request handlers\n    // to the \"setupServer\" call, all responses will be\n    // bypassed (performed as-is). This will allow us to\n    // collect the actual responses.\n    server.events.on(\"response:bypass\", (response_, requestId) => {\n      const request_ = requests.get(requestId);\n\n      const request = JSON.parse(JSON.stringify(request_));\n      request.headers = request_.headers.raw();\n\n      const response = JSON.parse(JSON.stringify(response_));\n      response.headers = response_.headers.raw();\n\n      transactions.add({ request, response });\n    });\n\n    function write() {\n      const json = existingJson;\n\n      transactions.forEach((transaction) => {\n        json.push(transaction);\n      });\n\n      fs.outputFileSync(cassetteFile, JSON.stringify(json, null, 2));\n    }\n\n    const onUnhandledRequest = { error: \"error\", record: \"bypass\" } as const;\n\n    server.listen({\n      onUnhandledRequest: onUnhandledRequest[config.onUnhandledRequest],\n    });\n\n    return function close() {\n      server.close();\n      write();\n    };\n  }\n\n  async function cassette<T>(\n    name: string,\n    callback: () => Promise<T>\n  ): Promise<T> {\n    const close = listen(name);\n    return callback().finally(() => close());\n  }\n\n  return {\n    listen,\n    cassette,\n  };\n}\n"]}